#!/bin/bash
#
# gw -- shk's git workflow (rebase)
# Copyright (C) 2012  Alan SCHNEIDER
#                     <shk.schneider[at]gmail.com>
#
# This program comes with ABSOLUTELY NO WARRANTY.
# This is free software, and you are welcome to redistribute it
# under certain conditions.
#

[ -z "$(which git)" ] && echo "gw: command 'git' not found" >&2 && exit 1
url="http://www.shkschneider.me/blog/1815/git-workflow-my-rebase-model/"

function usage() {
    echo "Usage: gw <COMMAND [...]>" >&2
    # commands starting with '-' make no changes on repository
    echo "" >&2
    echo "       -h, --help   -- this help" >&2
    echo "       -m, --model  -- this workflow's model" >&2
    echo "       -w, --what   -- what to do now (branch-specific help)" >&2
    echo "       -l, --list   -- relative statuses of all branches (graph)" >&2
    echo "       -s, --status -- relative status of the current branch (checklist)" >&2
    echo "" >&2
    # those commands can make changes on local and/or remote
    echo "       init [--force]            -- init a repository compliant with this workflow" >&2
    echo "       up[date]                  -- get updates from upstream branches" >&2
    echo "       pu[blish] [TAG ...]       -- publish updates in upstream branches" >&2
    echo "       n[ew-]h[otfix] <ID-DESC>  -- create a new private branch (from master)" >&2
    echo "       n[ew-]r[elease] <TAG>     -- create a new private branch (from devel)" >&2
    echo "       n[ew-]f[eature] <ID-DESC> -- create a new private branch (from devel)" >&2
    echo "       n[ew-]b[ugfix] <ID-DESC>  -- create a new private branch (from devel)" >&2
}

function gw_list() {
    type=$(echo $branch | cut -d'-' -f1)
    commit_hash=$(git rev-list --max-count=1 $branch 2>/dev/null | cut -c1-7)
    case $type in
	"master")
	    ahead=$(git log --oneline $branch...origin/master | wc -l | awk '{print $1}') ;;
	"devel"|"hotfix"|"release")
	    ahead=$(git log --oneline $branch...master | wc -l | awk '{print $1}') ;;
	"feature"|"bugfix")
	    ahead=$(git log --oneline $branch...devel | wc -l | awk '{print $1}') ;;
	*)
	    ahead="?" ;;
    esac
    case $type in
	"master")           echo -n "" ;;
	"devel")            echo -n "\`-----" ;;
	"hotfix"|"release") echo -n "|\`--" ;;
	"feature"|"bufix")  echo -n "      \`--" ;;
	*)                  echo -n "??? " ;;
    esac
    remote=$(git ls-remote 2>/dev/null | egrep "refs/remotes/origin/$branch\$" | cut -c1-7)
    local=$(git rev-parse $branch | cut -c1-7)
    [ -n "$remote" ] && branch="origin/$branch"
    echo "$branch [$commit_HASH] +$ahead"
}

function gw_publish_master() {
    echo "== gw == preparing '$current' to be published to 'origin/master'"
    git checkout $current
    git rebase origin/master || exit 1
    git checkout master
    echo "== gw == publishing '$current' to 'master'"
    git rebase $current
    echo "== gw == tagging 'master' with 'git tag $@'"
    git tag $@ HEAD || exit 1
}

function gw_publish_devel() {
    echo "== gw == preparing '$current' to be published to 'origin/devel'"
    git checkout $current
    git rebase origin/devel || exit 1
    # squash commits
    n=$(git log --oneline HEAD...origin/devel | wc -l | awk '{print $1}')
    [ $n -eq 0 ] && echo "gw: nothing changed from 'origin/devel'" >&2
    [ $n -eq 1 ] && git commit --amend
    [ $n -ge 2 ] && git rebase -i HEAD~$n
    git checkout devel
    echo "== gw == publishing '$current' to 'devel'"
    git rebase $current
}

function gw_status_branch() {
    ahead=$(git log --oneline HEAD...$1 | wc -l | awk '{print $1}')
    if [ $ahead -gt 0 ] ; then
	echo "[ KO ] Ahead of '$1' (by $ahead commits)"
	#for commit in $(git log --oneline HEAD...$1 | cut -c1-7) ; do
	#    hash=$(echo $commit | cut -d'_' -f1)
	#    msg=$(git show --oneline $commit | head -1 | cut -d' ' -f2-)
	#    echo "       * [$hash] $msg"
	#done
    else
	echo "[ OK ] In synch with '$1'"
    fi
}

function gw_status_index() {
    if [ -n "$(git status --porcelain | egrep -v '^\?\?')" ] ; then
	echo "[ KO ] Index NOT clean"
    else
	echo "[ OK ] Index clean"
    fi
}

function gw_check_branch() {
    if [ -z "$1" ] ; then
	conflict=$(git status --short | egrep '^(.U|U.)')
	commits=$(git log --oneline | wc -l | awk '{print $1}')
	echo "gw: no branch selected" >&2
	[ -n "$conflict" ] && echo "    you are in the middle of a conflict: fix it" >&2
	[ $commits -eq 0 ] && echo "    repository is naked: try 'gw update' or 'gw init'" >&2
	exit 1
    fi
    local type=$(echo $1 | cut -d'-' -f1)
    case $type in
        "master"|"hotfix"|"release"|"devel"|"feature"|"bugfix") ;;
        *) echo "gw: '$1' branch not recognized" >&2 && exit 1 ;;
    esac
    [ -z "$(git branch | cut -c3- | egrep "^$1\$")" ] && echo "gw: '$1' branch does not exists" >&2 && exit 1
}

function gw_check_repository() {
    [ -z "$dir" ] && echo "gw: not a git repository" >&2 && exit 1
    [ -z "$(git remote)" ] && echo "gw: remote 'origin' does not exists" >&2 && exit 1
    git fetch --tags origin
    current=$(git symbolic-ref HEAD 2> /dev/null | cut -b 12-)
    type=$(echo $Current | cut -d'-' -f1)
    tag_hash=$(git rev-list --tags --max-count=1 2>/dev/null)
    [ -n "$tag_hash" ] && tag=$(git describe --tags $tag_hash) || tag=""
}

[ $# -eq 0 ] && usage && exit 1

dir=$(git rev-parse --git-dir 2>/dev/null)

case $1 in
    "init")
	[ -n "$(git status --porcelain | egrep -v '^\?\?')" ] && echo "gw: they are some things left to commit" >&2 && exit 1 ;;
    "-l"|"--list")
	gw_check_repository
	gw_check_branch master
	gw_check_branch devel
	;;
    "-s"|"--status")
	gw_check_repository
	gw_check_branch master
	gw_check_branch devel
	[ "$current" != "master" ] && [ "$current" != "devel" ] && gw_check_branch $current
	;;
    "-w"|"--what")
        [ -n "$dir" ] && gw_check_repository
        ;;
    "up"|"update"|"pu"|"publish"|"nh"|"new-hotfix"|"nr"|"new-release"|"nf"|"new-feature"|"nb"|"new-bugfix")
	gw_check_repository
	gw_check_branch master
	gw_check_branch devel
	[ "$current" != "master" ] && [ "$current" != "devel" ] && gw_check_branch $current
	[ -n "$(git status --porcelain | egrep -v '^\?\?')" ] && echo "gw: they are some things left to commit" >&2 && exit 1
	;;
esac
case $1 in
    "-m"|"--model")
	echo "Shk's Git Workflow - (Pull-)Rebase"
	echo "  Public branches:"
	echo "    origin/master -- production version (stable)"
	echo "    origin/devel  -- latest version (dev)"
	echo "  Private branches:"
	echo "    hotfix-ID-DESC [master] -- production bug fix"
	echo "    release-TAG [devel]     -- next release version (freeze)"
	echo "    feature-ID-DESC [devel] -- new feature"
	echo "    bugfix-ID-DESC [devel]  -- development bug fix"
	echo "Feel free to visit <$URL>"
	;;
    "-w"|"--what")
	if [ -z "$dir" ] ; then
	    echo "gw init            -- init a repository"
	else
	    case $type in
		"master")
		    echo "gw up[date]        -- pull from origin"
		    echo "gw pu[blish] [TAG] -- push to origin (latest tag is '$tag')"
		    ;;
		"hotfix"|"release")
		    echo "gw pu[blish] <TAG> -- merge into master and devel (latest tag is '$tag')"
		    ;;
		"devel")
		    echo "gw up[date]      -- pull from origin"
		    echo "gw pu[blish]     -- push to origin"
		    ;;
		"feature"|"bugfix")
		    echo "gw pu[blish]     -- merge into devel (interactive rebase)"
		    ;;
	    esac
	    echo "gw n[ew-]h[otfix]  -- fix a bug on 'master' branch"
	    echo "gw n[ew-]r[elease] -- freeze 'devel' branch into a new release"
	    echo "gw n[ew-]f[eature] -- clone 'devel' branch to add a new feature"
	    echo "gw n[ew-]b[ugfix]  -- fix a bug on 'devel' branch"
	fi
	;;
    "-l"|"--list")
	# known types
	for type in master hotfix release devel feature bugfix ; do
	    branches=$(git branch -a | cut -c3- | cut -d'/' -f3 | egrep "^$type" | sort -u)
	    for branch in $branches ; do
		gw_list $branch
	    done
	done
	# unknown types
	for branch in $(git branch -a | cut -c3- | rev | cut -d'/' -f1 | rev | sort -u | egrep -v '^(master$|devel$|hotfix-|release-|feature-|bugfix-)') ; do
	    gw_list $branch
	done
	;;
    "-s"|"--status")
	case $type in
	    "master")
		echo "Public branch: $current (latest tag is '$tag')"
		gw_status_branch origin/master
		commit_hash=$(git rev-list --max-count=1 HEAD 2>/dev/null)
		if [ -n "$tag_hash" ] && [ -n "$commit_hash" ] && [ "$tag_hash" != "$commit_hash" ] ; then
		    echo "[ KO ] Latest commit is NOT tagged (latest tag is '$tag')"
		    echo "       $ git tag TAG HEAD"
		else
		    echo "[ OK ] Latest commit is tagged '$tag'"
		fi
		;;
	    "devel")
		echo "Public branch: $current (latest tag is '$tag')"
		gw_status_branch origin/devel
		gw_status_branch origin/master
		;;
	    "hotfix"|"release")
		echo "Private branch: $current (latest tag is '$tag')"
		gw_status_branch master
		;;
	    "feature"|"bugfix")
		echo "Private branch: $current"
		gw_status_branch devel
		;;
	esac
	gw_status_index
	;;
    "init")
	[ -n "$2" ] && [ "$2" = "--force" ] && force="true" || force="false"
	if [ -n "$(git branch)" ] ; then
	    commits=$(git log --oneline | wc -l | awk '{print $1}')
            [ $commits -ne 0 ] && [ "$force" = "false" ] && echo "gw: repository already has history ($commits commits)" >&2 && exit 1
        fi
	echo master > README
        git add README
        git commit -m "* first master commit"
        echo "== gw == publishing 'master' to 'origin/master'"
        git push --force origin master
        gw_check_branch master
        git checkout --track -b devel master
        echo devel >> README
        git add README
	git commit -m "* first devel commit"
        git tag --force 0
        echo "== gw == publishing 'devel' to 'origin/master'"
        git push --tags --force origin devel
	echo "== gw == updating 'master' from 'origin/devel'"
        git checkout master
        git merge devel
        git push --tags --force origin master
        git checkout devel
        echo "== gw == you are now on 'devel' branch"
	;;
    "up"|"update")
	case $type in
	    "master"|"devel")             parent="$current" ;;
	    "hotfix")                     parent="master" ;;
	    "release"|"feature"|"bugfix") parent="devel" ;;
	esac
	echo "== gw == updating '$current' from 'origin/$parent'"
	git pull --rebase origin $parent
        git pull
	;;
    "pu"|"publish")
	case $type in
	    "master")
		shift
		echo "== gw == publishing 'master' to 'origin/master'"
		if [ $# -gt 0 ] ; then
		    echo "== gw == tagging 'master' with 'git tag $@'"
		    git tag --force $@ HEAD || exit 1
		fi
		git push --tags origin master
		;;
	    "devel")
		echo "== gw == publishing 'devel' to 'origin/devel'"
		git push --tags origin devel
		;;
	    "hotfix"|"release")
		shift
		[ $# -lt 1 ] && echo "gw: missing TAG parameter" >&2 && exit 1
		gw_publish_devel
		gw_publish_master $@
		echo "== gw == removing '$current' branch"
		git branch -d $current
		echo "== gw == you are on 'master' branch"
		;;
	    "feature"|"bugfix")
		gw_publish_devel
		echo "== gw == removing '$current' branch"
		git branch -d $current
		echo "== gw == you are on 'devel' branch"
		;;
	esac
	;;
    "nh"|"new-hotfix"|"nr"|"new-release"|"nf"|"new-feature"|"nb"|"new-bugfix")
	case $1 in
	    "nh"|"new-hotfix")  type="hotfix" ;;
	    "nr"|"new-release") type="release" ;;
	    "nf"|"new-feature") type="feature" ;;
	    "nb"|"new-bugfix")  type="bugfix" ;;
	esac
	desc=$(echo $2)
	[ -z "$desc" ] && usage && exit 1
	case $type in
	    "hotfix")                     parent="master" ;;
	    "release"|"feature"|"bugfix") parent="devel" ;;
	esac
	git checkout $parent
	echo "== gw == updating '$parent' from 'origin/$parent'"
	git fetch origin #$parent
	git rebase origin/$parent || exit 1
	echo "== gw == creating $type branch '$type-$desc' from '$parent'"
	git checkout --track -b $type-$desc $parent
	echo "== gw == you are on '$type-$desc' branch"
	;;
    "-h"|"--help")
	usage
	echo "" >&2
	echo "Feel free to visit <$URL>" >&2
	;;
    *)
	usage
	exit 1
	;;
esac

# EOF
